# Testing

## Setup

Let's take ``useTokenAllowance`` as an example.

In the ``useDApp`` monorepo we have prepared and use in tests some auxillary methods. The first one to know is ``setupTestingConfig``. It creates two networks (blockchain nodes), deploys multicall contract to them and creates a ``useDApp`` config object with the data about those two networks. You can also pass the version of multicall contract to use to the ``setupTestingConfig`` method. The default version is ``1``.

The second method we will take advantage of in this example is ``deployMockToken`` - it deploys an ERC20 token contract to the network. So the setup code might look something like this:

```tsx
  let token: Contract
  let config: Config
  let network1: TestingNetwork
  let deployer: Wallet
  let spender: Wallet

  beforeEach(async () => {
    ;({ config, network1 } = await setupTestingConfig())
    deployer = network1.wallets[0]
    spender = network1.wallets[1]
    token = await deployMockToken(deployer)
  })
```

## Testing

To check if the hook reads data correctly, we need to prepare it first. We approve the spender so that we can check if our hook returns the correct value.

To test the hook we need to render it using ``renderDAppHook``. It works like ``renderHook`` from the [react-testing-library](https://testing-library.com/docs/react-testing-library/intro/),
but it wraps the hook with additional contexts used by ``useDApp``. You can also pass the ``config`` object to the ``renderDAppHook`` method - that works in the same way as passing ``config`` to the ``DAppProvider`` component in the regular dApp.

React components are asynchronous. Reading data from the blockchain is also an async operation.
To get the return value from the hook, wait for the result to be set. You can do it with ``waitForCurrent``.

Then we can check if our result is correct. ``result.current`` is a value returned from our hook. It should be equal to 1 Ether.

```tsx
  await token.approve(spender.address, utils.parseEther('1'))

  const { result, waitForCurrent } = await renderDAppHook(
    () => useTokenAllowance(token.address, deployer.address, spender.address),
    {
      config,
    }
  )
  await waitForCurrent((val) => val !== undefined)

  expect(result.error).to.be.undefined
  expect(result.current).to.eq(utils.parseEther('1'))
```

## Full example

```tsx
  import type { Wallet, Contract } from 'ethers'
  import { useTokenAllowance } from '@usedapp/core'
  import { renderDAppHook, deployMockToken } from '@usedapp/testing'
  import chai, { expect } from 'chai'
  import { utils } from 'ethers'

  chai.use(solidity)

  describe('useTokenAllowance', () => {
    let token: Contract
    let config: Config
    let network1: TestingNetwork
    let deployer: Wallet
    let spender: Wallet

    beforeEach(async () => {
      ;({ config, network1 } = await setupTestingConfig())
      deployer = network1.wallets[0]
      spender = network1.wallets[1]
      token = await deployMockToken(deployer)
    })

    it('returns current allowance', async () => {
      await token.approve(spender.address, utils.parseEther('1'))

      const { result, waitForCurrent } = await renderDAppHook(
        () => useTokenAllowance(token.address, deployer.address, spender.address),
        {
          config,
        }
      )
      await waitForCurrent((val) => val !== undefined)

      expect(result.error).to.be.undefined
      expect(result.current).to.eq(utils.parseEther('1'))
    })
  })
```
